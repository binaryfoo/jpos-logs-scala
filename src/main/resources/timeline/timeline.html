<!doctype html>
<html>
<head>
  <script src="jquery-latest.min.js"></script>
  <script src="d3.v3.min.js" charset="utf-8"></script>
  <script src="d3-timeline.js"></script>

  <style type="text/css">
    .axis path,
    .axis line {
      fill: none;
      stroke: black;
      shape-rendering: crispEdges;
    }

    .axis text {
      font-family: sans-serif;
      font-size: 10px;
    }

    .timeline-label {
      font-family: sans-serif;
      font-size: 12px;
    }

    #rightBox {
      position: fixed;
      top: 0;
      right: 0;
      width: 350px;
      background-color: rgba(255, 255, 255, 0.7);
    }

    #eventListBox {
      height: 400px;
      overflow-y: scroll;
    }

    .coloredDiv {
      height:20px; width:20px; float:left;
    }

    #eventList {
      list-style-type: none;
      padding-left: 0;
    }

    #mousedMessage {
      height: 100%;
      overflow-y: visible;
    }

    rect.moused-over {
      fill: lightgrey !important;
    }
  </style>
  <script type="text/javascript">

    const timeFmt = d3.time.format("%H:%M:%S.%L");
    var preparedData;
    var offset;
    var pinnedSession;
    var mousedElement;

    const msgTypeToColor = new Map();
    msgTypeToColor.set('receive', '#aec7e8');
    msgTypeToColor.set('send', '#1f77b4');
    msgTypeToColor.set('peer-disconnect', '#ff7f0e');
    msgTypeToColor.set('session-error', '#d62728');
    msgTypeToColor.set('session-start', '#2ca02c');
    msgTypeToColor.set('connect', '#98df8a');
    msgTypeToColor.set('session-end', '#8c564b');
    msgTypeToColor.set('tcp-overflow', '#e377c2');
    msgTypeToColor.set('io-timeout', '#9467bd');
    msgTypeToColor.set('warn', '#ffbb78');

    const sessionsPerIpAddress = new Map();

    function colorForMsg(msgType) {
      let color = msgTypeToColor.get(msgType);
      return color ? color : '#bcbd22';
    }

    function msgTypeSortIndex(msgType) {
      return msgType == "receive" ? 0 : 1;
    }

    function prepare(data) {
      data.forEach((d) => {
        let dropTime = d.times.find((e) => e.msgType == "peer-disconnect" || e.msgType == "session-end");
        d.disconnect_time = dropTime == null ? 0 : dropTime.starting_time;
        let last_ending_time = 0;
        d.max_gap = 0;
        d.last_gap_time = 0;
        d.total_gap_time = 0;
        d.times.sort((a, b) => a.starting_time - b.starting_time);
        d.times.forEach((event) => {
          event.color = colorForMsg(event.msgType);
          if (last_ending_time) {
            let gap = event.starting_time - last_ending_time;
            d.max_gap = Math.max(d.max_gap, gap);
            if (gap > 100) {
              d.last_gap_time = last_ending_time;
            }
            d.total_gap_time += gap;
          }
          last_ending_time = event.ending_time;
        });
        d.timesByStartTime = d.times.slice();
        d.times.sort((a, b) => msgTypeSortIndex(a.msgType) - msgTypeSortIndex(b.msgType));
        let ipAddress = d.socket.split(':')[0];
        let sessionCount = sessionsPerIpAddress.get(ipAddress);
        sessionsPerIpAddress.set(ipAddress, sessionCount ? sessionCount + 1 : 1);
      });
      data = data.filter((d) => d.max_gap > 10);
//      return data.sort((a, b) => a.disconnect_time > b.disconnect_time);
      return data.sort((a, b) => a.last_gap_time - b.last_gap_time);
    }

    function formatEvent(d) {
      const lifespan = d.ending_time - d.starting_time;
      return timeFmt(new Date(d.starting_time)) + " <span style=\"color: " + colorForMsg(d.msgType) + "\">" + d.msgType + "</span> (" + lifespan + "ms) " + d.summary
    }

    function plot(data, startIndex, count = 1000) {
      offset = startIndex;
      const width = 1000;
      const chart = d3.timeline()
        .width(width * 4)
        .stack()
        .tickFormat({
          format: d3.time.format("%H:%M"),
          tickTime: d3.time.minutes,
          tickInterval: 1,
          tickSize: 6
        })
        .itemHeight(5)
        .itemMargin(2)
        .showAxisTop()
        .showTimeAxisTick()
        .margin({left: 70, right: 30, top: 0, bottom: 0})
        .hover(function (d, i, datum) {
          if (pinnedSession) {
            return;
          }
          // d is the current rendering object
          // i is the index during d3 rendering
          // datum is the id object
          let hoverIndex = datum.timesByStartTime.indexOf(d);
          let firstIndex = Math.max(0, hoverIndex - 3);
          let lastIndex = Math.min(datum.timesByStartTime.length, hoverIndex + 3);
          let closeTimes = datum.timesByStartTime.slice(firstIndex, lastIndex);

          mousedElement = event.currentTarget;
          mousedElement.classList.add("moused-over");
          document.getElementById('mousedMessage').src = window.location.origin + d.src;
          document.getElementById('lastGapTime').textContent = timeFmt(new Date(datum.last_gap_time)) + " (" + datum.total_gap_time + ")";

          const ipAddress = datum.socket.split(':')[0];
          const div = $('#hoverRes');
          div.find('#socket').html(datum.socket + " (<a href=\"#\" onclick=\"showSessionsForIp('" + ipAddress + "')\">" + sessionsPerIpAddress.get(ipAddress) + "</a> sessions)");
          d3.selectAll("#eventList li").remove();
          d3.select("#eventList")
            .selectAll()
            .data(closeTimes)
            .enter()
            .append("li")
            .html(formatEvent)
            .style('font-weight', (dd) => dd == d ? 'bold' : 'normal');
        })
        .mouseout(function (d) {
          if (!pinnedSession) {
            mousedElement.classList.remove("moused-over");
            mousedElement = null;
          }
        })
        .click(function (d, i, datum) {
          pinnedSession = datum.socket;
          document.getElementById("sessionPin").style.visibility = 'visible';
        });

      const slice = data.slice(offset, offset + count);
      d3.select("#timeline3").selectAll("svg").remove();
      const svg = d3.select("#timeline3").append("svg").attr("width", width * 4)
        .datum(slice).call(chart);
    }

    function showSessionsForIp(ipAddress) {
      let ipPrefix = ipAddress + ":";
      let sessionsForIp = preparedData.filter((d) => d.socket.startsWith(ipPrefix));
      plot(sessionsForIp, 0);
    }

    function unPinSession() {
      pinnedSession = null;
      document.getElementById("sessionPin").style.visibility = 'hidden';
      mousedElement.classList.remove("moused-over");
      mousedElement = null;
    }

    function reqListener() {
      const data = JSON.parse(this.responseText);
      preparedData = prepare(data);
      plot(preparedData, 0);
    }

    function navigateBy(increment) {
      plot(preparedData, Math.max(0, offset + increment));
    }

    function reqError(err) {
      console.log('Fetch Error :-S', err);
    }

    const oReq = new XMLHttpRequest();
    oReq.onload = reqListener;
    oReq.onerror = reqError;
    oReq.open('get', '/timeline.json', true);
    oReq.send();

  </script>
</head>
<body>
  <div>
    <div id="timeline3"></div>
  </div>
  <div id="rightBox">
    <div>
      <a href="#" onclick="navigateBy(-preparedData.length)">|&lt;&lt;</a>
      <a href="#" onclick="navigateBy(-1000)">&lt;</a>
      <a href="#" onclick="navigateBy(1000)">&gt;</a>
      <a href="#" onclick="navigateBy(preparedData.length-1000)">&gt;&gt;|</a>
    </div>
    <div id="hoverRes">
      <div class="coloredDiv"></div>
      <div>
        <span id="socket"></span>
        <span id="sessionPin" onclick="unPinSession()" style="visibility: hidden">X</span>
      </div>
    </div>
    <div id="eventListBox">
      <ol id="eventList"></ol>
      <div id="lastGapTime"></div>
      <iframe id="mousedMessage" src="" frameborder="0"></iframe>
    </div>
  </div>
</body>
</html>
